# [Gold IV] 소트 게임 - 1327 

[문제 링크](https://www.acmicpc.net/problem/1327) 

### 분류

너비 우선 탐색, 자료 구조, 그래프 이론, 그래프 탐색, 해시를 사용한 집합과 맵, 트리를 사용한 집합과 맵

### 문제 설명

<p>홍준이는 소트 게임을 하려고 한다. 소트 게임은 1부터 N까지 정수로 이루어진 N자리의 순열을 이용한다. 이 게임에선 K가 주어진다. 어떤 수를 뒤집으면, 그 수부터 오른쪽으로 K개의 수를 뒤집어야 한다. 예를 들어, 순열이 5 4 3 2 1 이었고, 여기서 K가 3일 때, 4를 뒤집으면 5 2 3 4 1이 된다. 반드시 K개의 수를 뒤집어야하기 때문에, 처음 상태에서 2나 1을 선택하는 것은 불가능하다.</p>

<p>입력으로 들어온 순열을 오름차순으로 만들려고 한다. 게임을 최대한 빨리 끝내고 싶을 때, 수를 최소 몇 개 선택해야 하는지 구해보자.</p>

### 입력 

 <p>첫째 줄에 순열의 크기 N과 K가 주어진다. 둘째 줄에 순열에 들어가는 수가 주어진다.</p>

### 출력 

 <p>첫째 줄에 정답을 출력한다. 만약 오름차순으로 만들 수 없으면 -1을 출력한다.</p>



#  🚀  오답노트 

```diff
+import java.util.*;
+import java.io.*;
+
+class Node {
+    String str;
+    int count;
+    
+    public Node(String str, int count){
+        this.str = str;
+        this.count = count;
+    }
+}
+
public class Main {
-    public static void main(String[] args) {
+    static int N, K;
+    static String answer = "";
+    
+    public static void main(String[] args) throws IOException{
        // 코드를 작성해주세요
+        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+        
+        String[] input = br.readLine().split(" ");
+        N = Integer.valueOf(input[0]);
+        K = Integer.valueOf(input[1]);
+        
+        StringBuilder sb = new StringBuilder();
+        input = br.readLine().split(" ");
+        for(int i=0; i<N; i++){
+            sb.append(input[i]);
+        }
+        
+        String init = sb.toString();
+        sb.setLength(0);
+        for(int i=1; i<=N; i++){
+            sb.append(i);
+        }
+        
+        answer = sb.toString();
+        
+        System.out.println(bfs(init));
+        
+        
    }
+    
+    static int bfs(String init){
+        Queue<Node> q = new LinkedList<>();
+        Set<String> visited = new HashSet<>();
+        q.add(new Node(init, 0));        
+        visited.add(init);
+        
+        int cnt = -1;
+        while(!q.isEmpty()){
+            Node cur = q.poll();
+            
+            if(cur.str.equals(answer)){
+                cnt = cur.count;
+                break;
+            }
+            
+            for(int i=0; i <= N-K; i++){
+                char[] arr = cur.str.toCharArray();
+                for(int j=0; j < K/2; j++){
+                    char tmp = arr[i+j];
+                    arr[i+j] = arr[i-j+K-1];
+                    arr[i-j+K-1] = tmp;
+                }
+                String result = String.valueOf(arr);
+                if(!visited.contains(result)){
+                    q.add(new Node(result, cur.count+1));
+                    visited.add(result);
+                }
+            }
+        }
+        return cnt;
+    }
}

```


 ## 🏆 전체 코멘트 

1. 분기 조건이 있으므로 BFS를 생각함
2. 처음에는 Node에 int[]을 넣으려고했는데 String을 사용하면 됨
3. 0~N-K까지 교환을 수행함
4. visited는 String이니까 set을 사용