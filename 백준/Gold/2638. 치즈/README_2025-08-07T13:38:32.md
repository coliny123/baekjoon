# [Gold III] 치즈 - 2638 

[문제 링크](https://www.acmicpc.net/problem/2638) 

### 분류

구현, 그래프 이론, 그래프 탐색, 시뮬레이션, 너비 우선 탐색, 깊이 우선 탐색, 격자 그래프

### 문제 설명

<p>N×M의 모눈종이 위에 아주 얇은 치즈가 <그림 1>과 같이 표시되어 있다. 단, N 은 세로 격자의 수이고, M 은 가로 격자의 수이다. 이 치즈는 냉동 보관을 해야만 하는데 실내온도에 내어놓으면 공기와 접촉하여 천천히 녹는다. 그런데 이러한 모눈종이 모양의 치즈에서 각 치즈 격자(작 은 정사각형 모양)의 4변 중에서 적어도 2변 이상이 실내온도의 공기와 접촉한 것은 정확히 한시간만에 녹아 없어져 버린다. 따라서 아래 <그림 1> 모양과 같은 치즈(회색으로 표시된 부분)라면 C로 표시된 모든 치즈 격자는 한 시간 후에 사라진다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/a4998beb-104c-4e37-b3d7-fd91cd81464a/-/preview/" style="width: 208px; height: 171px;"></p>

<p style="text-align: center;"><그림 1></p>

<p><그림 2>와 같이 치즈 내부에 있는 공간은 치즈 외부 공기와 접촉하지 않는 것으로 가정한다. 그러므 로 이 공간에 접촉한 치즈 격자는 녹지 않고 C로 표시된 치즈 격자만 사라진다. 그러나 한 시간 후, 이 공간으로 외부공기가 유입되면 <그림 3>에서와 같이 C로 표시된 치즈 격자들이 사라지게 된다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/e5d519ee-53ea-40a6-b970-710cca0db128/-/preview/" style="width: 208px; height: 171px;"></p>

<p style="text-align: center;"><그림 2></p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/a00b876a-86dc-4a82-a030-603a9b1593cc/-/preview/" style="width: 208px; height: 171px;"></p>

<p style="text-align: center;"><그림 3></p>

<p>모눈종이의 맨 가장자리에는 치즈가 놓이지 않는 것으로 가정한다. 입력으로 주어진 치즈가 모두 녹아 없어지는데 걸리는 정확한 시간을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에는 모눈종이의 크기를 나타내는 두 개의 정수 N, M (5 ≤ N, M ≤ 100)이 주어진다. 그 다음 N개의 줄에는 모눈종이 위의 격자에 치즈가 있는 부분은 1로 표시되고, 치즈가 없는 부분은 0으로 표시된다. 또한, 각 0과 1은 하나의 공백으로 분리되어 있다.</p>

### 출력 

 <p>출력으로는 주어진 치즈가 모두 녹아 없어지는데 걸리는 정확한 시간을 정수로 첫 줄에 출력한다.</p>



#  🚀  오답노트 

```diff
import java.util.*;
import java.io.*;

class Node {
-    int x, y, t;
+    int x, y;
    
-    public Node(int x, int y, int t){
+    public Node(int x, int y){
        this.x=x;
        this.y=y;
-        this.t=t;
    }
}

public class Main {
    public static int N, M;
    public static int[][] grid;
    public static int[][] contact;
    public static boolean[][] isAir;
    public static int[] dx = {0, 0, -1, 1};
    public static int[] dy = {-1, 1, 0, 0};
    public static Queue<Node> q = new LinkedList<>();
    
    public static void main(String[] args) throws IOException{
        // 코드를 작성해주세요
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        String[] input = br.readLine().split(" ");
        
        N = Integer.valueOf(input[0]);
        M = Integer.valueOf(input[1]);
        
        grid = new int[N][M];
-        contact = new int[N][M];
-        isAir = new boolean[N][M];
-        
        for(int i=0; i<N; i++){
            input = br.readLine().split(" ");
            for(int j=0; j<M; j++){
                grid[i][j] = Integer.valueOf(input[j]);
            }
        }
        
-        for(int i=0; i<M; i++){
-            if(!isAir[0][i] && grid[0][i] == 0){
-                q.add(new Node(0, i, 0));
-                isAir[0][i] = true;
-                contact[0][i] = 0;
+        int time = 0;
+        
+        while(true){
+            contact = new int[N][M];
+            isAir = new boolean[N][M];
+            
+            bfs(0, 0);
+            
+            boolean notMelted = false;
+            for(int i=0; i<N; i++){
+                for(int j=0; j<M; j++){
+                    if(grid[i][j] == 1 && contact[i][j] >= 2){
+                        grid[i][j] = 0;
+                        notMelted = true;
+                    }
+                }
            }
-            if(!isAir[N-1][i] && grid[N-1][i] == 0){
-                q.add(new Node(N-1, i, 0));
-                isAir[N-1][i] = true;
-                contact[N-1][i] = 0;
-            }
+            if(!notMelted) break;
+            time++;
        }
-        for(int i=0; i<N; i++){
-            if(!isAir[i][0] && grid[i][0] == 0){
-                q.add(new Node(i, 0, 0));
-                isAir[i][0] = true;
-                contact[i][0] = 0;
-            }
-            if(!isAir[i][M-1]&& grid[i][M-1] == 0){
-                q.add(new Node(i, M-1, 0));
-                isAir[i][M-1] = true;
-                contact[i][M-1] = 0;
-            }
-        }
        
-        int max = 0;
+        
+        System.out.println(time);
+    }
+    
+    
+    static void bfs(int x, int y){
+        q = new LinkedList<>();
+        q.add(new Node(x, y));
+        isAir[x][y] = true;
+        
        while(!q.isEmpty()){
            Node cur = q.poll();
            
-            max = Math.max(max, cur.t);
-            
            for(int i=0; i<4; i++){
                int nx = cur.x + dx[i];
                int ny = cur.y + dy[i];
                
                if(0 <= nx && nx < N && 0 <= ny && ny < M){
                    if(isAir[nx][ny]) continue;
                    if(grid[nx][ny] == 1){
                        contact[nx][ny]++;
-                        if(contact[nx][ny] >= 2){
-                            q.add(new Node(nx, ny, cur.t + 1));
-                            isAir[nx][ny] = true;
-                            grid[nx][ny] = 0;
-                        }
                    }else{
-                        q.add(new Node(nx, ny, cur.t));
+                        q.add(new Node(nx, ny));
                        isAir[nx][ny] = true;
                    }
                }
            }
        }
-        
-        
-        System.out.println(max);
    }
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

처음 코드는 BFS 과정에서 치즈를 즉시 녹이고 있어서, 먼저 녹은 치즈가 다른 치즈의 녹는 조건에 영향을 준다. => 치즈는 같은 시간에 동시에 녹아야 하므로 bfs내에서 q에 추가해주면 안됨
이를 위해 time마다 bfs를 수행하고 isAir배열과 contact 배열을 초기화하여 이전의 영향을 제거한다
최소 1회 검사하는데 100 * 100 = 10,000 이 걸림